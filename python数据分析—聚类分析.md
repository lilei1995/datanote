# **python**数据分析—聚类分析

聚类是将大量数据中具有“相似”特性 的数据点或者样本划分为一个类别。

聚类分析的基本哦是“物以类聚，人以群分”。因此大量的数据集中必然存在相似的数据样本。

在商业上，聚类可以帮助市场分析人员从消费者数据库中区分出不同的消费群体来，并且概括出每一类消费者的消费模式或者说习惯.

### 聚类算法的种类



##### 划分法

划分法(partitioning methods)，给定一个有N个元组或者纪录的数据集，分裂法将构造K个分组，每一个分组就代表一个聚类，K<N。而且这K个分组满足下列条件：

（1） 每一个分组至少包含一个数据纪录；

（2）每一个数据纪录属于且仅属于一个分组（注意：这个要求在某些模糊聚类算法中可以放宽）；

对于给定的K，算法首先给出一个初始的分组方法，以后通过反复迭代的方法改变分组，使得每一次改进之后的分组方案都较前一次好，而所谓好的标准就是：同一分组中的记录越近越好，而不同分组中的纪录越远越好。

大部分划分方法是基于距离的。给定要构建的分区数k，划分方法首先创建一个初始化划分。然后，它采用一种迭代的重定位技术，通过把对象从一个组移动到另一个组来进行划分。一个好的划分的一般准备是：同一个簇中的对象尽可能相互接近或相关，而不同的簇中的对象尽可能远离或不同。还有许多评判划分质量的其他准则。传统的划分方法可以扩展到子空间聚类，而不是搜索整个数据空间。当存在很多属性并且数据稀疏时，这是有用的。为了达到全局最优，基于划分的聚类可能需要穷举所有可能的划分，计算量极大。实际上，大多数应用都采用了流行的启发式方法，如k-均值和k-中心算法，渐近的提高聚类质量，逼近局部最优解。这些启发式聚类方法很适合发现中小规模的数据库中小规模的数据库中的球状簇。为了发现具有复杂形状的簇和对超大型数据集进行聚类，需要进一步扩展基于划分的方法。 [1] 

使用这个基本思想的算法有：[K-MEANS算法](https://baike.baidu.com/item/K-MEANS算法)、K-MEDOIDS算法、CLARANS算法；

##### 层次法

层次法(hierarchical methods)，这种方法对给定的数据集进行层次似的分解，直到某种条件满足为止。具体又可分为“自底向上”和“自顶向下”两种方案。

例如，在“自底向上”方案中，初始时每一个数据纪录都组成一个单独的组，在接下来的迭代中，它把那些相互邻近的组合并成一个组，直到所有的记录组成一个分组或者某个条件满足为止。

层次聚类方法可以是基于距离的或基于密度或连通性的。层次聚类方法的一些扩展也考虑了子空间聚类。层次方法的缺陷在于，一旦一个步骤（合并或分裂）完成，它就不能被撤销。这个严格规定是有用的，因为不用担心不同选择的组合数目，它将产生较小的计算开销。然而这种技术不能更正错误的决定。已经提出了一些提高层次聚类质量的方法。 [1] 

代表算法有：BIRCH算法、CURE算法、CHAMELEON算法等；



##### 密度算法

基于密度的方法(density-based methods)，基于密度的方法与其它方法的一个**根本区别**是：它不是基于各种各样的距离的，而是基于密度的。这样就能克服基于距离的算法只能发现“类圆形”的聚类的缺点。

这个方法的指导思想就是，只要一个区域中的点的密度大过某个[阈值](https://baike.baidu.com/item/阈值)，就把它加到与之相近的聚类中去。

代表算法有：DBSCAN算法、OPTICS算法、DENCLUE算法等；



##### 图论聚类法

图论聚类方法解决的第一步是建立与问题相适应的图，图的节点对应于被分析数据的最小单元，图的边（或弧）对应于最小处理单元数据之间的相似性度量。因此，每一个最小处理单元数据之间都会有一个度量表达，这就确保了数据的局部特性比较易于处理。图论聚类法是以样本数据的局域连接特征作为聚类的主要信息源，因而其主要优点是易于处理局部数据的特性。



##### 网格算法

基于网格的方法(grid-based methods)，这种方法首先将数据空间划分成为有限个单元（cell）的[网格结构](https://baike.baidu.com/item/网格结构),所有的处理都是以单个的单元为对象的。这么处理的一个突出的优点就是处理速度很快，通常这是与目标数据库中记录的个数无关的，它只与把数据空间分为多少个单元有关。

代表算法有：STING算法、CLIQUE算法、WAVE-CLUSTER算法；



##### 模型算法

基于模型的方法(model-based methods)，基于模型的方法给每一个聚类假定一个模型，然后去寻找能够很好的满足这个模型的数据集。这样一个模型可能是数据点在空间中的密度分布函数或者其它。它的一个潜在的假定就是：目标数据集是由一系列的[概率分布](https://baike.baidu.com/item/概率分布)所决定的。

通常有两种尝试方向：统计的方案和神经网络的方案。

![1568696490172](C:\Users\83759\AppData\Roaming\Typora\typora-user-images\1568696490172.png)

### 当心数据异常对于聚类结果的影响

**K均值**（K—means）是最常用的算法之一，根据点一点距离的相似度来

但在数据值异常的情况下，和在不用的维度和变量之间，如果存在数据闺蜜和量纲的差异，那么先做归一化和标准化。如果没有做，那么对数据的相似度有影响。

**DBSCAN**  （Density-based spatial clustering df applications whit noise）基于密度的的带有噪声的空间聚类

基于密度寻找被低密度区域分离的高密度空间，以此来实现不同数据样本的聚类。

### 在超大数据量时应该放弃K均值算法

当用作大量的实时运算时，K均值运算结果会被延迟。

相比较之下 Mini-batch  kmeans 保持了较高的类别识别率和计算效率。

### 聚类不仅是建模的终点，更是重要的中间预处理过程

#### 1.图像压缩

图像压缩就是用较少的数据量来表示原有的像素矩阵过程，这个过程称为图像编码，

K均值聚类分析是先定义K个颜色数量。然后将图像的不同颜色类放在不同的簇中，这样生成不同的簇来实现压缩的过程。

#### 2.图像分割

图像分割是将图像分成若干个特定的、具有独特性质的区域，并提出感兴趣的目标技术和过程。

聚类实施的关键是通过不同区域间明显不同的图像色彩特征做聚类。聚类数量就是要分割是区域的数量

#### 3.图像理解

从图像中获取深层次的信息

基于区域的的提取方法

#### 4.异常检测

基于距离的异常检测方法，计算样本间的距离，（曼哈顿距离，欧氏距离等），然后定义异常值

![img](https://img-blog.csdn.net/20180717213747321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTg3NTc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



#### 5，数据离散化

### 高维数据如何使用聚类

降维和子空间聚类



## python 实现聚类分析

Sklearn中的专门的聚类库cluster，

### 相关知识点

##### a,将算法对象保存到硬盘

再次做数据模型时，不需要重新训练模型，对象持久化。

python的cpickle库，可以将python的任意对象序列化/持久化。主要方法是dump和load

dump ： 将python序列化保存到本地文件

load: 从本地文件读取python对象并恢复实例对象。

##### b.字符串格式

| 符号   | 说明                                       |
| ------ | ------------------------------------------ |
| **%c** | **格式化字符及其 ASCII 码**                |
| **%s** | **格式化字符串**                           |
| **%d** | **格式化整数**                             |
| **%o** | **格式化无符号八进制数**                   |
| **%x** | **格式化无符号十六进制数**                 |
| **%X** | **格式化无符号十六进制数（大写）**         |
| %f     | 格式化浮点数字，可指定小数点后的精度       |
| %e     | 用科学计数法格式化浮点数                   |
| **%E** | **作用同 %e，用科学计数法格式化浮点数**    |
| **%g** | **根据值的大小决定使用 %f 或 %e**          |
| %G     | 作用同 %g，根据值的大小决定使用 %f 或者 %E |

变量可以通过格式化符号输出，例如：将a格式化后以str数据输出

`a=18`
`print("num is %d "%a)`
`b='中国'`
`print("i'm from  %s "%b)`

##### c . Python 的转义字符及其含义

| 符号 | 说明                 |
| ---- | -------------------- |
| \'   | 单引号               |
| \"   | 双引号               |
| \a   | 发出系统响铃声       |
| \b   | 退格符               |
| \n   | 换行符               |
| \t   | 横向制表符（TAB）    |
| \v   | 纵向制表符           |
| \r   | 回车符               |
| \f   | 换页符               |
| \o   | 八进制数代表的字符   |
| \x   | 十六进制数代表的字符 |
| \0   | 表示一个空字符       |
| \\   | 反斜杠               |

##### d.scatter和plot方法

###### scatter  散点图

`import matplotlib.pyplot as plt`

`fig = plt.figure()`
`ax = fig.add_subplot(111)`
`ax.scatter([1,2,3,4],[2,4,6,8],[10,20,30,40],['r', 'b','y','k'])   #x，y，大小，颜色，颜色也可以用随意的数字代替，比如[1,2,3,4]表示不同颜色即可，具体怎么设置想要的颜色后续再研究`
`plt.show()`



###### plot   折线图

```
# `encoding=utf-8`

`import matplotlib.pyplot as plt`
`from pylab import *                                 #支持中文`
`mpl.rcParams['font.sans-serif'] = ['SimHei']`

`names = ['5', '10', '15', '20', '25']`
`x = range(len(names))`
`y = [0.855, 0.84, 0.835, 0.815, 0.81]`
`y1=[0.86,0.85,0.853,0.849,0.83]`
`#plt.plot(x, y, 'ro-')`
`#plt.plot(x, y1, 'bo-')`
`#pl.xlim(-1, 11)  # 限定横轴的范围`
`#pl.ylim(-1, 110)  # 限定纵轴的范围`
`plt.plot(x, y, marker='o', mec='r', mfc='w',label=u'y=x^2曲线图')`
`plt.plot(x, y1, marker='*', ms=10,label=u'y=x^3曲线图')`
`plt.legend()  # 让图例生效`
`plt.xticks(x, names, rotation=45)`
`plt.margins(0)`
`plt.subplots_adjust(bottom=0.15)`
`plt.xlabel(u"time(s)邻居") #X轴标签`
`plt.ylabel("RMSE") #Y轴标签`
`plt.title("A simple plot") #标题`

`plt.show()`
```

![1568696098320](C:\Users\83759\AppData\Roaming\Typora\typora-user-images\1568696098320.png)

